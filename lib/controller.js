var _us = require('underscore');
var fs = require('fs');
var events = require('events');


// change this to a curry function which uses the router to
// build a controller.
// the controller listens to the router's event associated with
// it's name in order to process dispatched routes.
//exports.Controller = Controller;
var router;
/*
exports = function(router, viewer) {
    appRouter = router;
    appViewer = viewer;
    return Controller;
};
*/
module.exports = Controller

Controller.setRouter = function(router_singleton) {
    router = router_singleton;
}
Controller.setMimes = function( mimes_config ) {
}
//Controller.set

// The base controller definition
/**
 *  The cotroller renders static assets and templates using the parameters
 *  passed to the member functions.
 *
 *  @param {function} constructor     The constructor function for this controller.  Currently only supports name.
 */
function Controller( constructor ) {
    if ( !constructor.extended_by_nails_controller ) {
        if ( !constructor.name ) throw 'FATAL ERROR::: Named function required for Controller constructor method';
        constructor.extended_by_nails_controller = true;
        constructor.prototype.__proto__ = new Controller(constructor);
        return new constructor();
    }

    // configure event listeners on router.
    var controller_name = constructor.name.toLowerCase();
    router.removeAllListeners('dispatchTo:' + controller_name);
    router.on( 'dispatchTo:' + controller_name, this._do.bind(this) );

    /* TODO: remove this in leaue of _do or dispatch function
    function handleDispatchedRequest(action, params, request, response) {
        var doAction = self[action];
        if (typeof doAction != 'function') {
            self[404](request, response);
        } else {
            try {
                doAction(params, request, response);
            } catch(e) {
                // TODO: use domains to handle server errors
                self[500](request, response);
            }
        }
    };
    */

}

//Controller.prototype = new events.EventEmitter();

/****  Network Methods  *****/
/**
 *  The main entry function of the controller.
 *
 *  @param {string} action      The action called for this controller
 *  @param {object} params     The parameter hash for this action
 *  @param {object} request     The http request object from the http server
 *  @param {object} response    The http response object from the http server
 */
Controller.prototype._do = function( action, params, request, response ) {
    //this.emit( '_do', action, params, request, response );
    //this._generateResponse( action, params, request, response );
    request.handled_by_controller = true;
    var doAction = this[action];
    console.log(this.constructor.name, 'doing', action);
    if (typeof doAction != 'function') {
        this['404'](params, request, response);
    } else {
        try {
            doAction(params, request, response);
        } catch(e) {
            // TODO: look into domains for handle server errors
	        params.error = e;
            this['500'](params, request, response);
        }
    }
}

/** TODO: move this to view/viewer
 * Handles the action and params passed to this controller effectively
 *
 *  @param {string} action      The action requested by the router
 *  @param {object} params      The params generated by the router from the request url
 *  @param {object} request     The initial request object (may not actually be needed)
 *  @param {object} response    The response to write to
 */
/*
Controller.prototype._generateResponse: function( action, params, request, response ) {
    var responseData;
    if ( typeof this[action] != 'function' ) {
        responseData = this[404](params);
    } else {
        responseData = this[action](params);
    }
    this.render( response, responseData );
},
*/

/**
 *  Write to the response using the params returned by dispatch
 *
 *  @param {object} response        The response object to write to
 *  @param {object} responseParams  The object containing info to write to response
 */
/* TODO: appviewer is an obsolete concept. Controller will have it's own
 * overridable rendering logic
controller.prototype.render: function( viewName, viewData, request, response ) {
    appViewer._render( viewName, viewData, request, response );
},
*/

/**
 *  Hook for serving a static file. Use if the file parameter exists
 *
 *  @param {object} params  The route params for the file request
 */
/*
file: function( params ) {
    // TODO: Abstract path concatenation into its own file which worries about slashes (/)
    // TODO: optimize file manipulation to use asynchronous read/writes and memory buffers
    var path = params.path ? params.path + '/' + params.file : '/' + params.file;
    var content;
    try {
        content = this.getAsset( params.ext, path );
    } catch(err) {
        return this[404]();
    }
    // TODO: abstract these objects out to a function
    // success/fail/redirect, etc.
    return {
        code: 200,
        header: {'Content-Type': Nails.application.mimes[params.ext]},
        content: content
    };
},
*/

/**
 *  The default index function for retrieving the index
 */
Controller.prototype.index = function index( params, request, response ) {
    response.statusCode = 200;
    response.end('successfully got to index');
}

/** 
 *  The default route for public files 
 */
Controller.prototype.public = function(params, request, response ) {
    console.log('requested public:', request.path);
    response.public({path: request.path});
}

/**
 *  The default handler for a 404 error code
 */
Controller.prototype['404'] = function(params, request, response) {
    //this._render('404');
    response.setHeader('content-type', 'text/plain');
    response.statusCode = 404;
    response.end('Page Not Found');
}

/**
 *  The default handler for a 500 error code
 */
Controller.prototype['500'] = function(params, request, response) {
    //this._render('404');
    // Check if the stack has been passed along
    var error = params.error;
    var stackTrace = error.stack || '' || error;
    console.log('error with params', params);

    response.setHeader('content-type', 'text/plain');
    response.statusCode = 500;
    response.end('Internal Server Error\n\n' + stackTrace);
}

/***** UTILITY FUNCTIONS *****/
// Eventer accessor methods
Controller.prototype.error = function() {
    this.emit('error', arguments);
}

// Asset getter methods
/**
 *  Retrieves named view content for the controller action
 *
 *  @param {string} view    The name of the view to retrieve.
 */
/*
getView: function( view ) {
    var path = Nails.application.config.VIEWS_ROOT +
            [ '', this.name, (view) ? view : this.getView.caller.name ].join('/');
    return fs.readFileSync( filePath, 'utf8' );
},
*/

/**
 *  Returns a static asset
 *
 *  @param {string}   ext   The file extension of this asset
 *  @param {string}   path  The path to this asset (from root directory for this asset type)
 */
/*
Controller.prototype.get_asset = function( ext, path ) {
    var filePath = this.rootPathForType(ext) + path;
    return fs.readFileSync( filePath );
};
*/

/**
 * TODO: simplify this.  I'm making this too complicated.  Just let the public files route do the work.
 *  Returns the path for a specific static file type.
 *
 *  @param {string}  ext    The file extension of this asset
 */
/*
Controller.prototype.rootPathForType = function( ext ) {
    var config = Nails.application.config;
    var type = Nails.application.mimes[ext] ? Nails.application.mimes[ext].type : null ;
    if ( !type ) return config.STATIC_ROOT;
    return {
        page: config.STATIC_ROOT,
        style: config.CSS_ROOT,
        image: config.IMG_ROOT,
        script: config.JS_ROOT
    }[type];
}
*/
